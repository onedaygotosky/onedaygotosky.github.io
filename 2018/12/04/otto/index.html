<!DOCTYPE html>





<html lang="zh">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="概念从监听者模式说起在写代码的场景中，我们经常碰到“希望当发生某种情况能触发一段逻辑”的需求。拿Android举例，最常见的例子就是当某个按钮被点击时，做一段逻辑。如果说让事件处理的一方决定触发的时机，那只能不断轮询看是否发生了点击事件来决定触发逻辑了，显然是行不通的。12345while(true) &amp;#123;	if (view.isClick()) &amp;#123;		// do somethi">
<meta name="keywords" content="android">
<meta property="og:type" content="article">
<meta property="og:title" content="Android事件总线——otto介绍和源码解读">
<meta property="og:url" content="http://yoursite.com/2018/12/04/otto/index.html">
<meta property="og:site_name" content="无异说">
<meta property="og:description" content="概念从监听者模式说起在写代码的场景中，我们经常碰到“希望当发生某种情况能触发一段逻辑”的需求。拿Android举例，最常见的例子就是当某个按钮被点击时，做一段逻辑。如果说让事件处理的一方决定触发的时机，那只能不断轮询看是否发生了点击事件来决定触发逻辑了，显然是行不通的。12345while(true) &amp;#123;	if (view.isClick()) &amp;#123;		// do somethi">
<meta property="og:locale" content="zh">
<meta property="og:image" content="http://yoursite.com/2018/12/04/otto/post.png">
<meta property="og:updated_time" content="2019-08-19T16:20:56.515Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android事件总线——otto介绍和源码解读">
<meta name="twitter:description" content="概念从监听者模式说起在写代码的场景中，我们经常碰到“希望当发生某种情况能触发一段逻辑”的需求。拿Android举例，最常见的例子就是当某个按钮被点击时，做一段逻辑。如果说让事件处理的一方决定触发的时机，那只能不断轮询看是否发生了点击事件来决定触发逻辑了，显然是行不通的。12345while(true) &amp;#123;	if (view.isClick()) &amp;#123;		// do somethi">
<meta name="twitter:image" content="http://yoursite.com/2018/12/04/otto/post.png">
  <link rel="canonical" href="http://yoursite.com/2018/12/04/otto/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Android事件总线——otto介绍和源码解读 | 无异说</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">无异说</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">功不唐捐</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-home">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-archives">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/otto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="无异">
      <meta itemprop="description" content="程序员进行时">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无异说">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Android事件总线——otto介绍和源码解读

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              
                
              

              <time title="Created: 2018-12-04 00:24:28" itemprop="dateCreated datePublished" datetime="2018-12-04T00:24:28+08:00">2018-12-04</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-08-20 00:20:56" itemprop="dateModified" datetime="2019-08-20T00:20:56+08:00">2019-08-20</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/android/" itemprop="url" rel="index"><span itemprop="name">android</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="从监听者模式说起"><a href="#从监听者模式说起" class="headerlink" title="从监听者模式说起"></a>从监听者模式说起</h2><p>在写代码的场景中，我们经常碰到“希望当发生某种情况能触发一段逻辑”的需求。拿Android举例，最常见的例子就是当某个按钮被点击时，做一段逻辑。</p><p>如果说让事件处理的一方决定触发的时机，那只能不断轮询看是否发生了点击事件来决定触发逻辑了，显然是行不通的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (view.isClick()) &#123;</span><br><span class="line">		<span class="comment">// do something</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>



<p>Android中是通过调用这个view的<code>setOnclickListener</code>方法实现的。设置了listener之后，当点击事件发生时，就会调用listener中的onClick方法。这里的重点在于，触发处理事件逻辑的职责变为由事件产生方来承担。</p>
<p>这就是观察者模式。</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote>
<p>观察者模式：定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>一般说观察者模式有下面几个主要概念</p>
<ul>
<li>抽象主题(Subject)角色</li>
<li>具体主题(ConcreteSubject)角色</li>
<li>抽象观察者(Observer)角色</li>
<li>具体观察者(ConcreteObserver)角色</li>
</ul>
<p>事件总线像是更进一步，所有的主题和观察者的关系由事件总线调配，当要关心一个事件的时候，只需要在bus上注册就好，产生事件后也是在bus发送。</p>
<img src="/2018/12/04/otto/post.png" title="post">

<p>otto、eventbus之类的库的好处在于，解耦了事件产生发送和处理的逻辑。比如在多人多模块开发中，我只需要知道我要关心某个事件，使用注解把处理逻辑和事件绑定就行。至于这个事件是哪里怎么被发送出来的，我完全不用关心。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><a href="https://github.com/square/otto" target="_blank" rel="noopener">仓库地址</a></p>
<p>用gradle构建的话，只需要在build.gradle里加上</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">compile</span> <span class="string">'com.squareup:otto:1.3.8'</span></span><br></pre></td></tr></table></figure>

<p>就可以了。</p>
<p>otto的使用十分简单。使用@Subscribe注解标记监听方法，@Producer注解使用到的场景少些，用来标记能产生被监听的事件的方法。</p>
<p>首先在想要监听事件的地方定义处理事件的方法，在方法上加上@Subscribe注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answerAvailable</span><span class="params">(SomeEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理事件event</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把这个类用register方法注册到事件总线上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Bus bus = <span class="keyword">new</span> Bus();</span><br><span class="line">bus.register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<p>之后，只需要在事件发生的地方，调用post方法把事件post出去，上面@subscribe注册的方法就会收到事件。当然，register和post的要是同一个bus。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus.post(<span class="keyword">new</span> SomeEvent());</span><br></pre></td></tr></table></figure>

<p>当post了一个事件之后，上面register过的被@Subscribe标记的<code>answerAvailable</code>就会被调用，并且post的事件会作为参数传入。事件和监听者的匹配是otto根据发送的事件和监听方法的参数类型自动匹配的。加上调用方法的时候事件会作为参数传入，otto要求@Subscribe注解标记的方法一定是<strong>有且只有一个参数，并且是修饰符为pubic void。</strong></p>
<p>除了@Subscribe注解，还有一个@Produce注解，用来标记一个产生事件的方法。</p>
<p><em>虽然otto官方已经标记为deprecated并停止维护，推荐使用RxJava和RxAndroid，不过otto大部分情况下依然可以满足需求，并且足够简单</em></p>
<h1 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h1><p>其实otto的代码很简单，类也不多。所有代码结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── AnnotatedHandlerFinder.java  // 实际负责解析 @Produce和@Subscrib注解</span><br><span class="line">├── Bus.java                     // 事件总线，提供subscribe、post、unsubscribe方法</span><br><span class="line">├── DeadEvent.java               // 当发送事件没有找到注册者时会被发送，可以注册用于log</span><br><span class="line">├── EventHandler.java            // 表示一个监听者</span><br><span class="line">├── EventProducer.java           // 表示一个事件生产者</span><br><span class="line">├── HandlerFinder.java           // 解析监听者</span><br><span class="line">├── Produce.java                 // @Produce注解</span><br><span class="line">├── Subscribe.java               // @Subscribe注解</span><br><span class="line">└── ThreadEnforcer.java          // 线程策略</span><br></pre></td></tr></table></figure>

<p>各个类名字后面的注释已经说明了用途。其实简单来说，事件总线框架需要提供的是表达监听某个事件的发生，并在事件发生后执行一段逻辑的手段。</p>
<p>整个框架中最重要的就是三个方法:</p>
<ul>
<li>register</li>
<li>post</li>
<li>unregister</li>
</ul>
<h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><p>某个事件发生后流程从Bus.post()方法开始，然后触发处理逻辑。先来看下post方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Event to post must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    enforcer.enforce(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;Class&lt;?&gt;&gt; dispatchTypes = flattenHierarchy(event.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> dispatched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; eventType : dispatchTypes) &#123;</span><br><span class="line">      Set&lt;EventHandler&gt; wrappers = getHandlersForEventType(eventType);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wrappers != <span class="keyword">null</span> &amp;&amp; !wrappers.isEmpty()) &#123;</span><br><span class="line">        dispatched = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (EventHandler wrapper : wrappers) &#123;</span><br><span class="line">          enqueueEvent(event, wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dispatched &amp;&amp; !(event <span class="keyword">instanceof</span> DeadEvent)) &#123;</span><br><span class="line">      post(<span class="keyword">new</span> DeadEvent(<span class="keyword">this</span>, event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dispatchQueuedEvents();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>判完空之后会调用Enforcer的enforce方法。post、register、unregister方法都会用Enforcer来负责检查当前线程实是否符合要求。Enforcer接口默认有两个实现，<code>ANY</code>任意线程，<code>MAIN</code>限制主线程。因为默认使用<code>MAIN</code>，有时候我们碰到信息为<code>Event bus accessed from non-main thread</code>的Exception，就是这个原因。</p>
<p><code>flattenHierarchy()</code>方法是找到当前事件的父类，所以当post一个事件时，在这个事件的父类上注册的方法也会被调用到。</p>
<p><code>getHandlersForEventType()</code>这一步很关键，这是根据当前事件的类型找到在这个事件类型上注册的所有方法，以便后面能调用这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Set&lt;EventHandler&gt; <span class="title">getHandlersForEventType</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> handlersByType.get(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这个方法十分的简单。说明事件类型和注册方法的对应关系是之前就收集记录好了的。查看<code>handlersByType</code>被调用的地方，就知道这个收集工作是在<code>register</code>方法完成的。先继续看完<code>post</code>方法的流程，再回过头来看<code>register</code>方法。</p>
<p><em>获取当前事件的注册方法时，当发现这个事件类型没有被注册过，会发送一个deadEvent <code>post(new DeadEvent(this, event))</code></em></p>
<p><code>post</code>里拿到当前事件类型对应的注册方法后，调用<code>dispatchQueuedEvents()</code>方法把事件分发下去。最后会调用到<code>EventHandler</code>类的<code>handleEvent()</code>方法。<code>EventHandler</code>实际上表示的就是一个注册方法，在<code>register</code>中我们也会看到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(Object event)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(toString() + <span class="string">" has been invalidated and can no longer handle events."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method.invoke(target, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e.getCause() <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) e.getCause();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这里就是把事件作为参数通过反射调用注册方法。这样，也就完成了通知观察者的流程，走到事件处理逻辑。</p>
<h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>回过头来看register方法。</p>
<p>前面说到，事件类型和注册方法的对应关系是在register方法中收集的，而这正是register方法的主要主要作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Object to register must not be null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    enforcer.enforce(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, EventProducer&gt; foundProducers = handlerFinder.findAllProducers(object);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; type : foundProducers.keySet()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> EventProducer producer = foundProducers.get(type);</span><br><span class="line">      EventProducer previousProducer = producersByType.putIfAbsent(type, producer);</span><br><span class="line">      <span class="comment">//checking if the previous producer existed</span></span><br><span class="line">      <span class="keyword">if</span> (previousProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Producer method for type "</span> + type</span><br><span class="line">          + <span class="string">" found on type "</span> + producer.target.getClass()</span><br><span class="line">          + <span class="string">", but already registered by type "</span> + previousProducer.target.getClass() + <span class="string">"."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</span><br><span class="line">      <span class="keyword">if</span> (handlers != <span class="keyword">null</span> &amp;&amp; !handlers.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (EventHandler handler : handlers) &#123;</span><br><span class="line">          dispatchProducerResultToHandler(handler, producer);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; foundHandlersMap = handlerFinder.findAllSubscribers(object);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; type : foundHandlersMap.keySet()) &#123;</span><br><span class="line">      Set&lt;EventHandler&gt; handlers = handlersByType.get(type);</span><br><span class="line">      <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//concurrent put if absent</span></span><br><span class="line">        Set&lt;EventHandler&gt; handlersCreation = <span class="keyword">new</span> CopyOnWriteArraySet&lt;EventHandler&gt;();</span><br><span class="line">        handlers = handlersByType.putIfAbsent(type, handlersCreation);</span><br><span class="line">        <span class="keyword">if</span> (handlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlers = handlersCreation;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">final</span> Set&lt;EventHandler&gt; foundHandlers = foundHandlersMap.get(type);</span><br><span class="line">      <span class="keyword">if</span> (!handlers.addAll(foundHandlers)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Object already registered."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Set&lt;EventHandler&gt;&gt; entry : foundHandlersMap.entrySet()) &#123;</span><br><span class="line">      Class&lt;?&gt; type = entry.getKey();</span><br><span class="line">      EventProducer producer = producersByType.get(type);</span><br><span class="line">      <span class="keyword">if</span> (producer != <span class="keyword">null</span> &amp;&amp; producer.isValid()) &#123;</span><br><span class="line">        Set&lt;EventHandler&gt; foundHandlers = entry.getValue();</span><br><span class="line">        <span class="keyword">for</span> (EventHandler foundHandler : foundHandlers) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!producer.isValid()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (foundHandler.isValid()) &#123;</span><br><span class="line">            dispatchProducerResultToHandler(foundHandler, producer);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>主要分为对@Produce注解的处理和对@Subscribe注解的处理两部分，最后都会走到AnnottedHandlerFinder的loadAnnotatedMethods</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadAnnotatedMethods</span><span class="params">(Class&lt;?&gt; listenerClass,</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;Class&lt;?&gt;, Method&gt; producerMethods, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; subscriberMethods)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Method method : listenerClass.getDeclaredMethods()) &#123;</span><br><span class="line">      <span class="comment">// The compiler sometimes creates synthetic bridge methods as part of the</span></span><br><span class="line">      <span class="comment">// type erasure process. As of JDK8 these methods now include the same</span></span><br><span class="line">      <span class="comment">// annotations as the original declarations. They should be ignored for</span></span><br><span class="line">      <span class="comment">// subscribe/produce.</span></span><br><span class="line">      <span class="keyword">if</span> (method.isBridge()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (parameterTypes.length != <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">" has @Subscribe annotation but requires "</span></span><br><span class="line">              + parameterTypes.length + <span class="string">" arguments.  Methods must require a single argument."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (eventType.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">" has @Subscribe annotation on "</span> + eventType</span><br><span class="line">              + <span class="string">" which is an interface.  Subscription must be on a concrete class type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((method.getModifiers() &amp; Modifier.PUBLIC) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">" has @Subscribe annotation on "</span> + eventType</span><br><span class="line">              + <span class="string">" but is not 'public'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Method&gt; methods = subscriberMethods.get(eventType);</span><br><span class="line">        <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">          methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">          subscriberMethods.put(eventType, methods);</span><br><span class="line">        &#125;</span><br><span class="line">        methods.add(method);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(Produce.class)) &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">if</span> (parameterTypes.length != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">"has @Produce annotation but requires "</span></span><br><span class="line">              + parameterTypes.length + <span class="string">" arguments.  Methods must require zero arguments."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getReturnType() == Void.class) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method</span><br><span class="line">              + <span class="string">" has a return type of void.  Must declare a non-void type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; eventType = method.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (eventType.isInterface()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">" has @Produce annotation on "</span> + eventType</span><br><span class="line">              + <span class="string">" which is an interface.  Producers must return a concrete class type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (eventType.equals(Void.TYPE)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">" has @Produce annotation but has no return type."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((method.getModifiers() &amp; Modifier.PUBLIC) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Method "</span> + method + <span class="string">" has @Produce annotation on "</span> + eventType</span><br><span class="line">              + <span class="string">" but is not 'public'."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (producerMethods.containsKey(eventType)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Producer for type "</span> + eventType + <span class="string">" has already been registered."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        producerMethods.put(eventType, method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PRODUCERS_CACHE.put(listenerClass, producerMethods);</span><br><span class="line">    SUBSCRIBERS_CACHE.put(listenerClass, subscriberMethods);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>方法虽然很长，其实就是遍历当前注册的对象的方法，找到被@Subscriber和@Produce注解标记的方法，并且把结果缓存了起来。</p>
<p>这些被找到的方法会和这个对象本身被包装成EventHandler和EventProducer，以便需要的时候反射调用。</p>
<p>从EventHandler的构造函数就能看出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventHandler(Object target, Method method) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个逻辑是 ，在register中，如果当前注册监听的事件在之前有注册的producer，producer会生产事件并分发给监听者。</p>
<h2 id="unregister"><a href="#unregister" class="headerlink" title="unregister"></a>unregister</h2><p>unregiseter比较简单，就是把当前类的所有@Subscribe注册方法反注册，后续不会再收到事件。@Producer注解的方法失效，不会再产生事件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个流程其实就是register里根据注解收集事件类型和监听方法的对应关系，post的根据之前的记录分发反射调用监听方法，unregister反注册。</p>
<p>因为使用了注解来关联事件和监听者，代码写起来更加方便，也更加解耦。API足够简单，基本上register、post、unregister就可以满足需求，同时也提供了扩展功能。</p>
<p>注册需要在运行时遍历所有方法，并且调用监听方法是通过反射的，效率上会有所牺牲，不过一般来说，影响微乎其微。</p>
<p><strong>otto的代码很简洁，但是很有效，使用起来作用也很大。所以重要的还是设计理念。</strong></p>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li>要在合适的地方调用unregister，避免内存泄漏。因为bus持有注册对象是强引用的。如果注册的是Activity的话，可以在onDestroy方法中调用unregister。</li>
<li>可以注册一个监听DeadEvent事件的方法，打印log，以发现某个发送事件没有监听者的情况。</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/android/" rel="tag"># android</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/08/02/measure/" rel="prev" title="view的绘制过程(一)——measure">
                  view的绘制过程(一)——measure <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#从监听者模式说起"><span class="nav-number">1.1.</span> <span class="nav-text">从监听者模式说起</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用"><span class="nav-number">1.2.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">1.3.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#源码解读"><span class="nav-number">2.</span> <span class="nav-text">源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#post"><span class="nav-number">2.1.</span> <span class="nav-text">post</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#register"><span class="nav-number">2.2.</span> <span class="nav-text">register</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unregister"><span class="nav-number">2.3.</span> <span class="nav-text">unregister</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">2.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tips"><span class="nav-number">3.</span> <span class="nav-text">Tips</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">无异</p>
  <div class="site-description" itemprop="description">程序员进行时</div>
</div>
  <nav class="site-state motion-element">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">categories</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
        
      </div>
    
  </nav>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">无异</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  


  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>
<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
